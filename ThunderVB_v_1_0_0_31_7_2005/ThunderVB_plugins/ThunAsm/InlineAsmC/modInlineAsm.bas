Attribute VB_Name = "modInlineAsm"
Option Explicit
Declare Function disasm_vb Lib "ndisasm_dll.dll" Alias "_disasm_vb@8" (ByRef dat As Byte, ByRef strout As Byte) As Long
Declare Function CopyFile Lib "kernel32" Alias "CopyFileA" (ByVal lpExistingFileName As String, ByVal lpNewFileName As String, ByVal bFailIfExists As Long) As Long

Global donot_GenHeaders As Boolean
Global ch_path As String, ah_path As String

'Revision history:
'23/8/2004[dd/mm/yyyy] : Created by Raziel
'Module Created , intial version
'Coded Hook and TrogleHook functions
'
'25/8/2004[dd/mm/yyyy] : Edited by Raziel
'Many bug fixes , code has full error checking
'Changes For InlineC
'
'26/8/2004[dd/mm/yyyy] : Edited by Raziel
'Assembly Listing Unnamed variables fixing , partial
'Using a Customized version of nDisAsm (in dll) to disassemble
'
'29/8/2004[dd/mm/yyyy] : Edited by Raziel
'Many bugfixes to prevent crashes, even better error handling
'Added logmsg calls to log if enbaled
'Incude file needed is copied to the directory [strIncFileData]
'
'29/8/2004[dd/mm/yyyy] : Edited by Raziel
'More crashes fixed [numberAsmLines]
'
'12/10/2004[dd/mm/yyyy] : Edited by Raziel
'GPF exeption code
'
'4/12/2004[dd/mm/yyyy] : Edited by Raziel
'Sliht edits for plugin based code..
'better asm inserting..
'
'13/2/2004[dd/mm/yyyy] : Edited by Raziel
'Auto generated VB<->C function names aliases
'

Sub ProcInlineAsm(str As String)
Dim sMasmOut As String, masm_exe As String, temp_s As String
On Error GoTo errH:
GPF_Set GPF_RaiseErr, "modInlineAsm", "ProcInlineAsm", PLUGIN_NAME
        masm_exe = Get_Paths(ml)
        LogMsg "Inserting Asm Code", "modInlineAsm", "ProcInlineAsm"
        If FileExist(file_asm) = False Then
            If FileLen(file_asm) = False Then
                ErrorBox "Asm Listing Does not exist", "modInlineAsm", "ProcInlineAsm"
                LogMsg "Error:Asm Listing Does not exist", "modInlineAsm", "ProcInlineAsm"
                GoTo CleanUp
            End If
        End If
        
        file_include = GetPath(file_asm) & "listing.inc"
        SaveFile file_include, strIncFileData
        DoEvents ' to save the file
        temp_s = LoadFile(file_asm)
        'fix the asm file (compitable with masm >v5.10)
        'so it can be compiled,do any other fixing is needed
        FixAsm temp_s
        'proccess the asm blocks
        ProcAsmBlocks temp_s
        'Insert the Pure asm code
        ProcPureAsm temp_s
        'Insert the asm code
        'temp_s = Replace(temp_s, "'#asm'", vbNewLine, , , vbTextCompare)
        ProcAsmLines temp_s
        'output the processed asm listing
        
        'PATCH LIBOR - make Asm-Listenings pretty ;-)
        'disable this when you think there is some bug on "Fix Asm feature"
        'temp_s = MakeAsmListeningPretty(temp_s)
        
        SaveFile file_asm, temp_s
        DoEvents
        'inlineC
        procInlineC file_asm
        If Cancel_compile = True Then GoTo CleanUp
        'No need to numer the lines , using scintilla that adds the lines ;)
        'just to let the files to get refreshed..
        DoEvents
        LogMsg "Assebling", "modInlineAsm", "ProcInlineAsm"
        'execute masm if it exists
        Dim tempM As String
                
        If (Len(masm_exe) > 0) And FileExist(masm_exe) Then
            tempM = Add34(masm_exe) & " /c /Cp /coff " & Add34(file_asm)
            If ExecuteCommand(tempM, sMasmOut, GetPath(masm_exe)) = False Then GoTo error_masm_exe
        Else
error_masm_exe:
            ErrorBox "Masm Not found" & vbNewLine & _
                   "make sure that the masm Path is corect on the addin settings" & vbNewLine & _
                   "The curect masm path is : " & masm_exe, "modInlineAsm", "ProcInlineAsm"
            If MsgBoxX("Cancel Compile?", "Masm Error", vbYesNo Or vbQuestion) = vbYes Then Cancel_compile = True
            GoTo CleanUp
        End If

        If FileExist(GetPath(masm_exe) & GetFilename(file_obj)) = False Then
            'oh well masm din't created the .obj file , so assembling error
            frmMasmError.ShowError tempM & vbNewLine & sMasmOut, LoadFile(file_asm)
        End If
        
        If Cancel_compile = True Then GoTo CleanUp
        
        'copy the obj generated by mas to the compile directory
        If CopyFile(GetPath(masm_exe) & GetFilename(file_obj), file_obj, True) <> 0 Then
            'if succeed , then delete the generated masm file from the masm dir
            kill2 GetPath(masm_exe) & GetFilename(file_obj)
        Else
            ErrorBox "Can't copy file to target directory" & vbNewLine & _
                   "From : " & GetPath(masm_exe) & GetFilename(file_obj) & vbNewLine & _
                   "To    : " & file_obj, "modInlineAsm", "ProcInlineAsm"
        End If
CleanUp:        'cleanup and exit
        Cancel_compile = False
        kill2 file_asm
        kill2 file_include
GPF_Reset
Exit Sub

errH:
    If ErrorBox(Err.Description & vbNewLine & "do you want to continure??", _
                "modInlineAsm", "ProcInlineAsm", 16 Or vbYesNo) = vbYes Then
        Resume Next
    Else
        GoTo CleanUp
    End If
    
End Sub

'Do any fixes required to make the listing assemblamle corectly
Sub FixAsm(ByRef temp As String)
Dim Fix_unnamed As Boolean
    
    Fix_unnamed = CBool(Get_ASM(FixASMListings))
    If Fix_unnamed Then
        LogMsg "Asm Listing Fix is on", "modInlineAsm", "FixAsm"
        'WarnBox "Asm Listing Fix is on , this should work most times but it is in BETA stage", "modInlineAsm", "ProcInlineAsm"
        FixAsm_unnamed_vars temp
    End If
    'make it comp with masm >510
    FixAsm_masm temp

End Sub

'add this :
'if @Version gt 510...
'else....
'endif <- we look for this and we add this :
'OPTION NOSCOPE         ;Added By ThunVB to fix label problems
'ASSUME  CS: FLAT, DS: FLAT, ES: FLAT, FS: FLAT, GS: FLAT, SS: FLAT ;Added by ThunVB
Sub FixAsm_masm(ByRef str As String) 'Make the file compitable with masm > than v5.1
Dim i As Long, lines() As String

    lines = Split(str, vbNewLine)
    'for all the lines
    For i = 0 To UBound(lines)
        If InStr(1, lines(i), "endif", vbTextCompare) = 1 Then 'we must do it here
        lines(i) = lines(i) & vbNewLine & _
                   "OPTION NOSCOPED ;Added By ThunVB to fix label problems" & vbNewLine & _
                   "ASSUME  CS: FLAT, DS: FLAT, ES: FLAT, FS: FLAT, GS: FLAT, SS: FLAT ;Added by ThunVB"
                   
            Exit For
        End If
    Next i
    str = Join$(lines, vbNewLine)

End Sub

'Not totaly corect , relies on nDisAsm dll
'fix unamed vars compiler bug
'This works by striping out the compile code bytes generated from the -FAsc
'and dissasembling them , to get the corect asm instuctions
Sub FixAsm_unnamed_vars(ByRef str As String)
Dim i As Long, lines() As String, temp As String, oldlen As Long, temp2 As String

    lines = Split(str, vbNewLine)
    'for all the lines
    For i = 0 To UBound(lines)
        oldlen = Len(lines(i))
        temp2 = GetFirstWord(RTrim$(Trim$(Replace(lines(i), vbTab, " "))))
        
        If (Len(temp2) = 5) And IsNumeric("&h" & temp2) Then
            temp = FixAsm_hexs_line(lines(i))
            'well if the codebytes are extended and to the next line..
            If Len(lines(i)) = 0 And (oldlen > 0) Then
                i = i + 1
                temp = temp & " " & FixAsm_hexs_line(lines(i))
            End If
            If InStr(1, lines(i), "unnamed", vbTextCompare) Then
                lines(i) = FixUnnamedVarsPart(GetAsmFromOpcode(temp), lines(i))
            End If
        End If
    Next i
    str = Join$(lines, vbNewLine)

End Sub
Function FixUnnamedVarsPart(disasm As String, orig As String) As String
Dim t As String_B, strT1() As String, strT2() As String, i As Long
    
    'lea eax,[ebp-  96]
    'lea     eax, DWORD PTR _unnamed_var1$[ebp]
    disasm = Trim$(disasm)
    orig = Trim$(orig)
    
    strT1 = Split(orig, " ", 2)
    strT2 = Split(disasm, " ", 2)
    AppendString t, strT1(0) & " " 'instruction , eg mov
    
    'split and get all the parameters
    strT1 = Split(strT1(1), ",")
    strT2 = Split(strT2(1), ",")
    
    For i = 0 To UBound(strT1)
        If InStr(1, strT1(i), "unnamed", vbTextCompare) Then
            AppendString t, strT2(i) 'append the fixed
        Else
            AppendString t, strT1(i) 'no problen
        End If
        If (i <> UBound(strT1)) Then AppendString t, ","
    Next i
    
    AppendString t, ";" & orig
    
    FixUnnamedVarsPart = GetString(t)
End Function
'removes the hexs numbers before instruction and returns them
Function FixAsm_hexs_line(ByRef str As String) As String 'fix one line
Dim out As String_B

    str = Replace(str, vbTab, "    ")
    'we want to remove the numbers that the vb compiler
    'adds on the listings..
    'they are on the format :
    '[hhhhh] [hh] [hh] [hh] [hh] ... [asm command]
    'where h means a hex digit [ ]  means that it is optional
    If Mid$(str, 1, 1) = ";" Then GoTo ext 'well this line is a comment
    str = Trim(str) 'remove any space in the start/end of the string
    Do While IsNumeric("&h" & GetFirstWord(str)) = True And Len(str) > 0 'this is a valid hex number and the string still exists
        If Len(GetFirstWord(str)) = 3 Then GoTo ext 'no hex is in three numbers, but posssibly a "add","daa" ect
        AppendString out, GetFirstWord(str) & " "
        RemFisrtWord str 'remove the fisrt word
        str = Trim(str) 'remove any space
    Loop
ext:
    If out.str_index > 0 Then
        FixAsm_hexs_line = GetString(out)
    End If
    
End Function

'Convert asm inline blocks to '#asm' prefixed lines,works on the hole source
Sub ProcAsmBlocks(ByRef str As String) 'edit the asm blocks so that they are recognised
Dim i As Long, lines() As String, temp As String, asm As Boolean
    
    lines = Split(str, vbNewLine)
    'we look for lines in the folowing format ; number : other data
    For i = 0 To UBound(lines)
        temp = lines(i): temp = Trim(temp)
        If GetFirstWord(temp) = ";" Then 'starts with a ";"
            RemFisrtWord temp: temp = Trim(temp)
            If IsNumeric(GetFirstWord(temp)) Then 'the second word is  number
                RemFisrtWord temp: temp = Trim(temp)
                If GetFirstWord(temp) = ":" Then ' and the third word is a ":"
                    RemFisrtWord temp: temp = Trim(temp)
                    ProcAsmBlocks_line temp, asm, lines(i), i 'proccess it
                End If
            End If
        End If
    Next i
    str = Join$(lines, vbNewLine)
    
End Sub

'Covert a asm block to many '#asm' prefixed instructions,works on a line
Sub ProcAsmBlocks_line(ByRef str As String, ByRef asm As Boolean, ByRef sOut As String, i As Long)

    'if it is a coment then
    If Mid(str, 1, 1) <> "'" Then Exit Sub
    'remove the coment and any space after it
    str = Right(str, Len(str) - 1)
    str = Trim(str)
    'if asm_start/end command
    If InStr(1, str, "#asm_start", vbTextCompare) = 1 Then asm = True: Exit Sub
    If InStr(1, str, "#asm_end", vbTextCompare) = 1 Then asm = False: Exit Sub
    'if inside asm block
    If asm = False Then Exit Sub
    'and if the line is not a comand (eg '#asm')
    If Mid(str, 1, 1) = "#" Then Exit Sub
    'expand the block to many '#asm' lines so that they can be recognised
    str = "; asm block expanded  : '#asm' " & str
    'write the output
    sOut = str

End Sub


 'uncoment '#asm' lines  so that they are inserted ;)
Sub ProcAsmLines(ByRef str As String)
Dim i As Long, lines() As String, temp As String, asm As Boolean
    
    lines = Split(str, vbNewLine)
    'we look for lines in the folowing format ; number : other data
    For i = 0 To UBound(lines)
        temp = lines(i): temp = Trim(temp)
        If GetFirstWord(temp) = ";" Then 'starts with a ";"
            RemFisrtWord temp: temp = Trim(temp)
            If IsNumeric(GetFirstWord(temp)) Then 'the second word is  number
                RemFisrtWord temp: temp = Trim(temp)
                If GetFirstWord(temp) = ":" Then ' and the third word is a ":"
                    RemFisrtWord temp: temp = Trim(temp)
                    If InStr(1, temp, "'#asm'", vbTextCompare) = 1 Then ' if asm line
                        lines(i) = Right(temp, Len(temp) - 6) & vbTab & lines(i)
                    End If
                End If
            End If
        End If
    Next i
    str = Join$(lines, vbNewLine)
    
End Sub

'number the lines for easy bug finding
'not used now because we user scintilla to present the asm code that has line numbers..
Sub NumberAsmLines(ByRef strg As String)

    Dim i As Long
    Dim lines() As String
    lines = Split(strg, vbNewLine)
    LogMsg UBound(lines) & " lines", "modInlineAsm", "NumberAsmLines"
    'number the lines for easy bug finding '104 leters space ->104/8 -> 13 tabs
    For i = 0 To UBound(lines)
        lines(i) = lines(i) & String$(IIf(Len(lines(i)) > 104, Len(lines(i)) + 10, 104) - Len(lines(i)), " ") & " ; line number : " & i + 1
        'LogMsg i & " : " & lines(i), "modInlineAsm", "NumberAsmLines"
    Next i
    
    strg = Join$(lines, vbNewLine)

End Sub


'retry to assmeble the asm code
Sub retryAsm(temp_s As String)
Dim sMasmOut As String, masm_exe As String

    masm_exe = Get_Paths(ml)
    SaveFile file_asm, temp_s
        
    If ExecuteCommand(Add34(masm_exe) & " /c /Cp /coff " & Add34(file_asm) _
                                    , sMasmOut, GetPath(masm_exe)) Then
    
    Else
        ErrorBox "Masm Not found", "modInlineAsm", "retryAsm"
    End If
    
    If FileExist(GetPath(masm_exe) & GetFilename(file_obj)) = False Then
        frmMasmError.ShowError Add34(masm_exe) & " /c /Cp /coff " & Add34(file_asm) & vbNewLine & sMasmOut, LoadFile(file_asm)
    End If
    
End Sub

'Get ASM string from x86 opcode
'A basic dissasebler ;).. as teh comnst below says , i'm too bored to code
'a full x86 dissassebler .. this works on many cases but
'i made a dll of ndisasm that is working on all the cases so..
Function GetAsmFromOpcode(ByVal opcode As String) As String
Dim ff As Long, sOut As String, sopcode As String, temp As Long

    If Len(RTrim$(Trim$(opcode))) = 0 Then Exit Function
    RemFisrtWord opcode ' the 5 digit offset..
    sopcode = opcode
    'Using Nasm for now..
    GetAsmFromOpcode = GetAsmFromOpcodeNasm(sopcode)
    Exit Function
    'Ok this is the vb6 verion but it is incomplete...
    'Nasm can do the work much better and with full compatibilyty..
    'and very good speed (when in dll)
    'And , anyway , i'm tooo bored to make a x86 dissasebler just for this..
    'i prefer to do some other plugins [like realtime code formating..]
    'and yes , all the code here is hand writen , no generator used :P
    temp = val("&H" & GetFirstWord(opcode))
    RemFisrtWord opcode
    Select Case temp
    
        '884424  #1|#|        mov [esp+<#1>],al
        '884C24  #1|#|        mov [esp+<#1>],cl
        '885424  #1|#|        mov [esp+<#1>],dl
        '885C24  #1|#|        mov [esp+<#1>],bl
        Case &H88
        
            temp = val("&H" & GetFirstWord(opcode)) * 255
            RemFisrtWord opcode
            temp = temp + val("&H" & GetFirstWord(opcode))
            RemFisrtWord opcode
                
            Select Case temp
                
            '4424  #1|#|        mov [esp+<#1>],al
            Case 17444
                sOut = "mov [esp+" & SignedB(val("&H" & GetFirstWord(opcode))) & "],al"
                
            '4C24  #1|#|        mov [esp+<#1>],cl
            Case 19492
                sOut = "mov [esp+" & SignedB(val("&H" & GetFirstWord(opcode))) & "],cl"
                
            '5424  #1|#|        mov [esp+<#1>],dl
            Case 21540
                sOut = "mov [esp+" & SignedB(val("&H" & GetFirstWord(opcode))) & "],dl"
                
            '5C24  #1|#|        mov [esp+<#1>],bl
            Case 23588
                sOut = "mov [esp+" & SignedB(val("&H" & GetFirstWord(opcode))) & "],bl"
                
            Case Else
            GoTo lble
            
            End Select
            
        '894424  #1|#|        mov [esp+<#1>],eax
        '8945    #1|#|        mov [ebp-<#1>],eax
        '894C24  #1|#|        mov [esp+<#1>],ecx
        '894D    #1|#|        mov [ebp-<#1>],ecx
        '895424  #1|#|        mov [esp+<#1>],edx
        '895C24  #1|#|        mov [esp+<#1>],ebx
        '897424  #1|#|        mov [esp+<#1>],esi
        '8975    #1|#|        mov [ebp-<#1>],esi
        Case &H89
        
               
            temp = val("&H" & GetFirstWord(opcode))
            RemFisrtWord opcode

            Select Case temp
                
            '4424  #1|#|        mov [esp+<#1>],eax
            Case &H44
                If GetFirstWord(opcode) = "24" Then
                    RemFisrtWord opcode
                    sOut = "mov [esp" & SignedB(val("&H" & GetFirstWord(opcode))) & "],eax"
                Else
                    GoTo lble:
                End If
                    
            '45    #1|#|        mov [ebp-<#1>],eax
            Case &H45
                sOut = "mov [ebp" & SignedB(val("&H" & GetFirstWord(opcode))) & "],eax"
                
            '4C24  #1|#|        mov [esp+<#1>],ecx
            Case &H4C
                If GetFirstWord(opcode) = "24" Then
                    RemFisrtWord opcode
                    sOut = "mov [esp" & SignedB(val("&H" & GetFirstWord(opcode))) & "],ecx"
                Else
                    GoTo lble:
                End If
                
            '4D    #1|#|        mov [ebp-<#1>],ecx
            Case &H4D
                sOut = "mov [ebp" & SignedB(val("&H" & GetFirstWord(opcode))) & "],ecx"
                
            '5424  #1|#|        mov [esp+<#1>],edx
            Case &H54
                If GetFirstWord(opcode) = "24" Then
                    RemFisrtWord opcode
                    sOut = "mov [esp" & SignedB(val("&H" & GetFirstWord(opcode))) & "],edx"
                Else
                    GoTo lble:
                End If
                
            '5C24  #1|#|        mov [esp+<#1>],ebx
            Case &H5C
                If GetFirstWord(opcode) = "24" Then
                    RemFisrtWord opcode
                    sOut = "mov [esp" & SignedB(val("&H" & GetFirstWord(opcode))) & "],ebx"
                Else
                    GoTo lble:
                End If
                
            '7424  #1|#|        mov [esp+<#1>],esi
            Case &H74
                If GetFirstWord(opcode) = "24" Then
                    RemFisrtWord opcode
                    sOut = "mov [esp" & SignedB(val("&H" & GetFirstWord(opcode))) & "],esi"
                Else
                    GoTo lble:
                End If
                
            '75    #1|#|        mov [ebp-<#1>],esi
            Case &H75
                sOut = "mov [ebp+" & SignedB(val("&H" & GetFirstWord(opcode))) & "],esi"
                
            Case Else
            GoTo lble
            
            End Select
            
        
        '8B45    #1|#|        mov eax,[ebp-<#1>]
        Case &H8B
        '45    #1|#|        mov eax,[ebp-<#1>]
        If GetFirstWord(opcode) = "45" Then
            RemFisrtWord opcode
            sOut = "mov eax,[ebp" & SignedB(val("&H" & GetFirstWord(opcode))) & "]"
        Else
            GoTo lble:
        End If
        
        '8D4424  #1|#|        lea eax,[esp+<#1>]
        '8D45    #1|#|        lea eax,[ebp-<#1>]
        '8D4C24  #1|#|        lea ecx,[esp+<#1>]
        '8D4D    #1|#|        lea ecx,[ebp-<#1>]
        '8D5424  #1|#|        lea edx,[esp+<#1>]
        '8D55    #1|#|        lea edx,[ebp-<#1>]
        Case &H8D
        temp = val("&H" & GetFirstWord(opcode))
            RemFisrtWord opcode

            Select Case temp
                
            '4424  #1|#|        lea eax,[esp+<#1>]
            Case &H44
                If GetFirstWord(opcode) = "24" Then
                    RemFisrtWord opcode
                    sOut = "lea eax,[esp" & SignedB(val("&H" & GetFirstWord(opcode))) & "]"
                Else
                    GoTo lble:
                End If
            '45    #1|#|        lea eax,[ebp-<#1>]
            Case &H45
                sOut = "lea eax,[ebp" & SignedB(val("&H" & GetFirstWord(opcode))) & "]"
            '4C24  #1|#|        lea ecx,[esp+<#1>]
            Case &H4C
                If GetFirstWord(opcode) = "24" Then
                    RemFisrtWord opcode
                    sOut = "lea ecx,[esp" & SignedB(val("&H" & GetFirstWord(opcode))) & "]"
                Else
                    GoTo lble:
                End If
            '4D    #1|#|        lea ecx,[ebp-<#1>]
            Case &H4D
                sOut = "lea ecx,[ebp" & SignedB(val("&H" & GetFirstWord(opcode))) & "]"
            '5424  #1|#|        lea edx,[esp+<#1>]
            Case &H54
                If GetFirstWord(opcode) = "24" Then
                    RemFisrtWord opcode
                    sOut = "lea edx,[esp" & SignedB(val("&H" & GetFirstWord(opcode))) & "]"
                Else
                    GoTo lble:
                End If
            '55    #1|#|        lea edx,[ebp-<#1>]
            Case &H55
                sOut = "lea edx,[ebp" & SignedB(val("&H" & GetFirstWord(opcode))) & "]"
            Case Else
            GoTo lble
            
            End Select
            
        'C64424  #1 #1|#|     mov byte ptr [esp+<#1>],<@2>
        Case &HC6
        'C64424  #1 #1|#|     mov byte ptr [esp+<#1>],<@2>
        GoTo lble
        
        'C74424  #1 #4|#|     mov dword ptr [esp+<#1>],<@2>
        'C745    #1 #4|#|     mov dword ptr [ebp-<#1>],<@2>
        Case &HC7
        temp = val("&H" & GetFirstWord(opcode))
            RemFisrtWord opcode

            Select Case temp
                
            '4424  #1 #4|#|     mov dword ptr [esp+<#1>],<@2>
            Case &H44
                If GetFirstWord(opcode) = "24" Then
                    RemFisrtWord opcode
                    sOut = "mov dword ptr [esp" & SignedB(val("&H" & GetFirstWord(opcode))) & "]"
                    RemFisrtWord opcode
                    sOut = sOut & "," & val("&H" & Split(opcode, " ")(3) & Split(opcode, " ")(2) & Split(opcode, " ")(1) & Split(opcode, " ")(0))
                Else
                    GoTo lble:
                End If
            
            '45    #1 #4|#|     mov dword ptr [ebp-<#1>],<@2>
            Case &H45
             
                    sOut = "mov dword ptr [ebp" & SignedB(val("&H" & GetFirstWord(opcode))) & "]"
                    RemFisrtWord opcode
                    sOut = sOut & "," & val("&H" & Split(opcode, " ")(3) & Split(opcode, " ")(2) & Split(opcode, " ")(1) & Split(opcode, " ")(0))
                
            Case Else
            GoTo lble
            
            End Select

        Case Else
lble:
        sOut = GetAsmFromOpcodeNasm(sopcode)
        GoTo nmsg
    End Select
    
    'MsgBoxX sout & vbNewLine & GetAsmFromOpcodeNasm(sopcode) & vbNewLine & sopcode
nmsg:
    GetAsmFromOpcode = sOut
End Function

'Use nasm to dissassemble
Function GetAsmFromOpcodeNasm(ByVal opcode As String) As String
Dim temp(23) As Byte, sOut() As Byte, tind As Long, sout2 As String

    
    'write the data
    ReDim sOut(255)
    Do
        temp(tind) = CByte(val("&h" & GetFirstWord(opcode)))
        tind = tind + 1
        RemFisrtWord opcode: opcode = Trim$(opcode)
    Loop While Len(opcode)
    disasm_vb temp(0), sOut(0)
    ReDim Preserve sOut(Find0(sOut) - 1)
    sout2 = StrConv(sOut, vbUnicode)
    sout2 = replace0xwith0yyyh(Trim$(sout2))
    
    If Len(sout2) = 0 Then ErrorBox "Can't fix asm listing.." & vbNewLine & sout2, "modInlineAsm", "GetAsmFromOpcodeNasm"

    
    GetAsmFromOpcodeNasm = sout2
End Function

Function replace0xwith0yyyh(str As String) As String
Dim temp As String, pos As Long, l As Long, tmp As String, s As Long
    s = 1
rech:
    pos = InStr(s, str, "0x", vbTextCompare)
    l = 1
    Do While IsNumeric("&h" & Mid$(str, pos + 2, l)) And (pos + 2 + l) < (Len(str) + 2)
        l = l + 1
    Loop
    l = l - 1
    If pos > 0 Then
        tmp = val("&H" & Mid$(str, pos + 2, l))
        If Len(tmp) <= Len(Mid$(str, pos, l + 2)) Then
            tmp = Space((Len(Mid$(str, pos, l)) - Len(tmp)) + 2) & tmp
        Else
            ErrorBox tmp & vbNewLine & str, "modInlineAsm", "replace0xwith0yyyh"
        End If
        Mid$(str, pos) = tmp
        s = pos + 2 + l
        GoTo rech
    End If
    str = Replace(str, "dword", "dword PTR")
    replace0xwith0yyyh = str
    
End Function

'sign extend a byte
Function SignedB(val As Long) As String

    If val > 127 Then val = val - 256
    
    If val >= 0 Then
        SignedB = "+" & val
    Else
        SignedB = val
    End If
    
End Function

'Find 0 in a asni C string (as a byte array)
Function Find0(str() As Byte) As Long
Dim i As Long
    
    For i = 0 To UBound(str)
        If str(i) = 0 Then Exit For
    Next i
    Find0 = i
    
End Function

'has to be done in a good way .. this way can take a file without asm and say that is has asm :) :D
Public Function FileHasAsmOrC(file As String) As Boolean
    
    Dim file_data As String
    file_data = LoadFile(file)
    
    If (InStr(1, file_data, "'#asm'", vbTextCompare) Or InStr(1, file_data, "#asm_start", vbTextCompare) Or InStr(1, file_data, "'#c'", vbTextCompare)) Then
        FileHasAsmOrC = True
    Else
        FileHasAsmOrC = False
    End If
    
End Function

'Generates a asm object with the call aliases
'and a header for the C part to call vb's functions...
Public Function GenerateAsmCHeadersAndSave(asmobj As String, cheader As String) As Boolean
Dim t As String, t2 As String, obj_out As String

    obj_out = asmobj & ".obj"

    CreateAsmCHeader t, t2
    
    If Len(t) = 0 Then Exit Function
       
    t = ".386P" & vbNewLine & ".model FLAT" & vbNewLine & t & vbNewLine & " END"
    Dim sMasmOut As String, masm_exe As String

    masm_exe = Get_Paths(ml)
    
    SaveFile asmobj & ".asm", t
    SaveFile cheader, t2
    
    If ExecuteCommand(Add34(masm_exe) & " /c /Cp /coff /Fo" & Add34(obj_out) & " " & Add34(asmobj & ".asm") _
                                    , sMasmOut, GetPath(masm_exe)) Then
    
    Else
        ErrorBox "Masm Not found", "modInlineAsm", "GenerateAsmCHeadersAndSave"
    End If
    

    If FileExist(obj_out) = False Then
        ErrorBox "Can't  Assemble auto generated asm code ;Please report this error" & vbNewLine & sMasmOut, _
        "modInlineAsm", "GenerateAsmCHeadersAndSave"
        GenerateAsmCHeadersAndSave = False
        Exit Function
    End If
    
    GenerateAsmCHeadersAndSave = True
    
End Function



'Insert the C code on a vb module listing
Sub ProcPureAsm(ByRef str As String)
Dim asm() As String, i As Long, temp As String, temp2 As c_code_asm
Dim l1 As Long, tmp_l As String
    
    asm = Split(str, vbNewLine)
    LogMsg "Inserting PureAsm Code", "modInlineAsm", "ProcPureAsm"
    LogMsg UBound(asm) & " lines", "modInlineAsm", "ProcPureAsm"
    For i = 0 To UBound(asm)
        If Len(asm(i)) > 0 Then
            temp = GetLineFromLising(asm(i))
            If InStr(1, temp, "'#asm'.pureasm", vbTextCompare) = 1 Then
                LogMsg i & " : " & temp, "modInlineAsm", "ProcPureAsm"
                For l1 = i To 0 Step -1
                    If Len(asm(l1)) Then
                        If InStr(1, asm(l1), "PUBLIC", vbTextCompare) Then
                            tmp_l = Replace(Trim(asm(l1)), vbTab, "    ")
                            RemFisrtWord tmp_l: tmp_l = Trim(tmp_l)
                            temp2.fName = GetFirstWord(tmp_l)
                            Exit For
                        End If
                    End If
                Next l1
                If Len(temp2.fName) = 0 Then
                    ErrorBox "Error while looking for Public directive", "modInlineAsm", "ProcPureAsm"
                    Exit Sub
                End If
                'temp2.AsmCode
                Call GetInsertPureAsmCode(asm, i)
                'asm(i) = temp2.AsmCode
            End If
        End If
    Next i
    
    LogMsg "saving result", "modInlineAsm", "ProcPureAsm"
    
    str = Join$(asm, vbNewLine)
    DoEvents

    LogMsg "saved", "modInlineAsm", "ProcPureAsm"
    
End Sub


'Gets and removes a function that contains C from VB listing
Private Sub GetInsertPureAsmCode(str() As String, ByVal i As Long)
Dim curseg As String, i2 As Long, out As String_B, seg_s As Long, seg_e As Long, lastln As String
    'This  must be chnged too
    'Look for word "SEGMENT" and in the line containing it , take it's first word [segname SEGMENT]
    
    For i2 = i To 0 Step -1
        If Len(str(i2)) Then
            If InStr(1, str(i2), "SEGMENT", vbTextCompare) Then
                curseg = GetFirstWord(Replace(Trim(str(i2)), vbTab, "    "))
                seg_s = i2
                Exit For
            End If
        End If
    Next i2
    
    If InStr(1, str(seg_s - 2), "CONST" & vbTab & "ENDS", vbTextCompare) Then
        For i2 = seg_s - 1 To 0 Step -1
            If Len(str(i2)) Then
                If InStr(1, str(i2), "CONST" & vbTab & "SEGMENT", vbTextCompare) Then
                    str(i2) = ""
                    Exit For
                End If
                str(i2) = ""
            End If
        Next i2
    End If
    
    If Len(curseg) = 0 Then
        ErrorBox "Error while looking for SEGMENT directive", "modInlineAsm", "GetInsertPureAsmCode"
        Exit Sub
    End If
    
    For i2 = seg_s + 1 To UBound(str)
        If InStr(1, str(i2), curseg & vbTab & "ENDS", vbTextCompare) = 1 Then
            seg_e = i2
            'str(i2) = GetString(out) & vbNewLine & str(i2)
            Exit For
        Else
            If InStr(1, str(i2), "?", vbTextCompare) <> 1 Then
                lastln = Trim$(GetLineFromLising(str(i2)))
                If Len(lastln) Then
                    If InStr(1, lastln, "'#asm'", vbTextCompare) = 1 Then
                        If InStr(1, lastln, "'#asm'.pureasm", vbTextCompare) = 0 Then
                            'AppendString out, str(i2) & vbNewLine
                            GoTo NextI2
                        End If
                    End If
                End If
                str(i2) = ""
            End If
        End If
NextI2:
    Next i2
    

End Sub

Private Function MakeAsmListeningPretty(ByVal sData As String) As String
Dim i As Long, asNew() As String
Dim com As Long
    
    If Len(sData) = 0 Then Exit Function
    
    'don't change the order of the following lines ;-)
    
    sData = Replace(sData, vbTab, " ")    'remove tabs

    AdvReplace sData, "  ", " "            'remove doble-spaces
    AdvReplace sData, "- ", "-"           'kill space after minus
    sData = Replace(sData, "+ -", "-")    'remove this "+ -" shit

    sData = Replace(sData, ",", ", ")     'make code more readable
    AdvReplace sData, "  ", " "           'again kill all double-spaces
    
    AdvReplace sData, vbCrLf & vbCrLf, vbCrLf                    'kill double-lines

    sData = Replace(sData, "PUBLIC ?", vbCrLf & "PUBLIC ?")      'blank lines between subs
    sData = Replace(sData, ", COMDAT", ", COMDAT" & vbCrLf)      'blank line between function header and its code
    
    sData = Replace(sData, vbCrLf & "?", vbCrLf & vbCrLf & "?")  'just make code more readable
    sData = Replace(sData, vbCrLf & "$", vbCrLf & vbCrLf & "$")  'VB labels are prefixed by $
    
    'split array
    asNew = Split(sData, vbCrLf)
    
    For i = LBound(asNew) To UBound(asNew)

        'find comment
        com = InStr(1, asNew(i), ";")
        If com > 3 And com < 30 Then
            asNew(i) = Left(asNew(i), com - 1) & Space(30 - Len(Left(asNew(i), com))) & Mid(asNew(i), com)
        End If

    Next i
    
    MakeAsmListeningPretty = Join(asNew, vbCrLf)

End Function

'advanced Replace
Private Sub AdvReplace(ByRef Expr As String, ByRef sFind As String, ByRef Rep As String)

    Do
        Expr = Replace(Expr, sFind, Rep)
    Loop While InStr(1, Expr, sFind) <> 0

End Sub
